# 1.2 离散规划

TODO：为算法加个图

> 作者的废话：
>
> 如何规划路径让机械臂从一个状态变化到另一个状态？我一开始也很茫然。但是随着一步步展开，一切都显得顺理成章。这也是为什么作者拉扯出了第一章。离散规划中的定义和许多思想将会继续在连续空间中发挥作用。

在开始现实连续空间之前，不妨先从离散规划中了解一些常见的规划。如果您有计算机背景，那么将会对以下的图寻路算法比较熟悉。这里选择算法都是访问图的算法（可以理解为一次次查询得知图的样貌，而非一开始就知道全貌），因为在一些规划场景中，图是需要探索的（如果需要比喻，可以想一想战场迷雾，随着玩家的探索逐渐显示地图）。

### 前向搜索

FORWARD_SEARCH

```python
Q.Insert(x_I) and mark x_I as visited
while Q not empty do
    x = Q.pop()
    if x in X_G
    	return SUCCESS
    for all u in U(x)
    	x_new = f(x,u)
        if x_new not visited
            Mark x_new as visited
            Q.Insert(x_new)
		else
        	Resolve duplicate x_new
return FAILURE
```

前向搜索抽象地来说，就是从起点开始，逐个根据已知的条件挑选点访问获取更多信息，直到到达终点，生成路径树。

在伪代码中，Q是一个优先队列，它决定了访问的顺序，**许多搜索算法的唯一显著的区别就是Q的排序方法**。规划器需要选择合适的排序方式，确保能够找到解，或者宣布无解。对最优规划来说，还希望让构成最优解的顶点尽快（当然，首先要求能）被搜索到。

##### BFS，DFS

深度优先搜索DFS的Q是LIFO（栈），广度优先搜索BFS的Q是FIFO（顺序队列）；

##### Dijsktra

大名鼎鼎的Dijkstra，Q的value就是cost-to-come/C(x)，i.e. 从起点到当前点的树路径长度，这个代价在加入新的点时会不断更新。它是单源最优的。

##### Best First

与Dijkstra相对，Best First算法对cost-to-go/G(x)进行排序，也就是根据到终点的距离选择。当然，作为一棵正在生长的树，到终点的距离实际上是不可知的，所以这里用的是距离估计，一般是距离的下界。这个算法一般很快，但很可能不是最优的，最坏的情况下会很慢（比如一头扎进死路）。

##### A*

对Dijkstra进行扩展得到的A-star/A\*算法结合了二者，以f(x)=C(x)+G\*(x)为Q队列value。以终点为目标，更有目的性以减少探索量。

### 其他常见搜索结构

除了前向搜索，还有多种搜索结构，如后向搜索，双向搜索。后向搜索从终点开始（走迷宫的时候你会尝试从终点开始找路吗？），这种结构对于起点附近分叉较多的情况比较有效。双向搜索一般都可以降低搜索的范围，主要需要解决的问题是在于如何让两棵树快速遇上。